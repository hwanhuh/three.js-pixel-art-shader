<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js Pixel-Art Renderer with Controls</title>
    <style>
        body { margin: 0; }
        canvas { display: block; }
    </style>
</head>
<body>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
                "lil-gui": "https://unpkg.com/lil-gui@0.19.1/dist/lil-gui.esm.js"
            }
        }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import GUI from 'lil-gui';

        const scene = new THREE.Scene();
        const backgroundColor = new THREE.Color(0xcccccc);
        scene.background = backgroundColor;

        // GUI
        const gui = new GUI();
        const params = {
            effectiveResolutionX: 480,
            effectiveResolutionY: 320,
            outlineThickness: 0.01,
            outlineColor: '#030303',
            ditherStrength: 0.2,
            light1Color: '#ff0000',
            light2Color: '#00ff00',
            light3Color: '#0000ff',
            brightness: 5.0,
            animateModel: false,
            backgroundColor: '#' + backgroundColor.getHexString(),
            fadeOpacity: 0.6, 
            showOutline: true,
            ditherPattern: 'Bayer 4x4', // Dithering pattern selector
            halftoneSpacing: 8.0, 
            targetCurvature: 0.25
        };

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 0, 8);

        const renderer = new THREE.WebGLRenderer();
        renderer.setClearColor(backgroundColor);
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.target.set(0, 1, 0);

        // Render targets always at full window resolution
        const renderTargetOptions = {
            magFilter: THREE.NearestFilter,
            minFilter: THREE.NearestFilter,
            type: THREE.HalfFloatType
        };
        let renderTarget = new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight, renderTargetOptions);
        let readTarget = new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight, renderTargetOptions);
        let writeTarget = new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight, renderTargetOptions);

        const postFXScene = new THREE.Scene();
        const postFXCamera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
        
        // CRT style postFX material shader with pixelation simulation
        const postFXMaterial = new THREE.ShaderMaterial({
            uniforms: {
                uSceneTexture: { value: renderTarget.texture },
                uPrevFrameTexture: { value: readTarget.texture },
                uFadeOpacity: { value: params.fadeOpacity },
                uResolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
                uEffectiveRes: { value: new THREE.Vector2(params.effectiveResolutionX, params.effectiveResolutionY) },
                uAberrationAmount: { value: 0.002 },
                uScanlineIntensity: { value: 0.05 },
                uCurvatureAmount: { value: params.targetCurvature }, 
            },
            vertexShader: `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform sampler2D uSceneTexture;
                uniform sampler2D uPrevFrameTexture;
                uniform float uFadeOpacity;

                uniform vec2 uResolution; 
                uniform vec2 uEffectiveRes;
                uniform float uAberrationAmount;
                uniform float uScanlineIntensity;
                uniform float uCurvatureAmount;

                varying vec2 vUv;

                vec2 distortUV(vec2 uv) {
                    vec2 centeredUv = uv - 0.5;
                    float aspectRatio = uResolution.x / uResolution.y;
                    centeredUv.x *= aspectRatio;
                    float dist = dot(centeredUv, centeredUv);
                    vec2 distortedUv = uv + centeredUv * dist * uCurvatureAmount;
                    return distortedUv;
                }

                void main() {
                    vec2 distortedUv = distortUV(vUv);

                    // Simulate pixelation
                    vec2 pixelSize = 1.0 / uEffectiveRes;
                    distortedUv = floor(distortedUv / pixelSize) * pixelSize + pixelSize * 0.5;

                    vec4 newColor;
                    if (distortedUv.x < 0.0 || distortedUv.x > 1.0 || distortedUv.y < 0.0 || distortedUv.y > 1.0) {
                        newColor = vec4(0.0, 0.0, 0.0, 1.0);
                    } else {
                        vec2 offset = uAberrationAmount * (distortedUv - 0.5);
                        float r = texture2D(uSceneTexture, distortedUv - offset).r;
                        float g = texture2D(uSceneTexture, distortedUv).g;
                        float b = texture2D(uSceneTexture, distortedUv + offset).b;
                        newColor = vec4(r, g, b, 1.0);
                    }

                    float scanline = mod(gl_FragCoord.y, 2.0) * uScanlineIntensity;
                    newColor.rgb -= scanline;

                    vec4 oldColor = texture2D(uPrevFrameTexture, vUv);
                    gl_FragColor = mix(newColor, oldColor, uFadeOpacity);
                }
            `,
        });
        const postFXQuad = new THREE.Mesh(new THREE.PlaneGeometry(2, 2), postFXMaterial);
        postFXScene.add(postFXQuad);

        // --- Intro Animation State ---
        const introAnimation = {
            isActive: false,
            startTime: 0,
            duration: {
                stage1_highRes: 2000,  // Added pause for clean high-res
                stage2_crtAndPixel: 3000,  // Transition duration
            },
            totalDuration: 5000,
        };

        function startIntroAnimation() {
            introAnimation.startTime = performance.now();
            introAnimation.isActive = true;

            // Reset to starting state
            model.traverse(child => {
                if (originalMaterials.has(child)) {
                    child.material = originalMaterials.get(child);
                }
            });
            postFXMaterial.uniforms.uCurvatureAmount.value = 0;
            pixelMaterial.uniforms.uPixelationMix.value = 0.0;
            outlineMaterial.uniforms.uOutlineOpacity.value = 0.0;
            postFXMaterial.uniforms.uEffectiveRes.value.set(window.innerWidth, window.innerHeight);
            toggleOutlineVisibility(false);
        }

        const introControls = { replay: startIntroAnimation };
        gui.add(introControls, 'replay').name('Replay Intro');

        // --- Dithering Patterns Setup ---
        const bayer = new Uint8Array([ 0, 128, 32, 160, 192, 64, 224, 96, 48, 176, 16, 144, 240, 112, 208, 80 ]);
        const bayerTexture = new THREE.DataTexture(bayer, 4, 4, THREE.LuminanceFormat, THREE.UnsignedByteType);
        bayerTexture.magFilter = THREE.NearestFilter;
        bayerTexture.minFilter = THREE.NearestFilter;
        bayerTexture.wrapS = THREE.RepeatWrapping;
        bayerTexture.wrapT = THREE.RepeatWrapping;
        bayerTexture.needsUpdate = true;

        function createNoiseTexture(size) {
            const data = new Uint8Array(size * size);
            for (let i = 0; i < data.length; i++) data[i] = Math.random() * 255;
            const texture = new THREE.DataTexture(data, size, size, THREE.LuminanceFormat, THREE.UnsignedByteType);
            texture.magFilter = THREE.NearestFilter;
            texture.minFilter = THREE.NearestFilter;
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            texture.needsUpdate = true;
            return texture;
        }
        const whiteNoiseTexture = createNoiseTexture(64);
        const textureLoader = new THREE.TextureLoader();
        const blueNoiseTexture = textureLoader.load('bluenoise64.png', (texture) => {
            texture.magFilter = THREE.NearestFilter;
            texture.minFilter = THREE.NearestFilter;
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
        });

        const ditherPatterns = {
            'Bayer 4x4':        { mode: 0, texture: bayerTexture, resolution: new THREE.Vector2(4, 4) },
            'White Noise 64x64':{ mode: 0, texture: whiteNoiseTexture, resolution: new THREE.Vector2(64, 64) },
            'Blue Noise 64x64': { mode: 0, texture: blueNoiseTexture, resolution: new THREE.Vector2(64, 64) },
            'Halftone':         { mode: 1, texture: null, resolution: null }
        };

        // outline shader
        const outlineMaterial = new THREE.ShaderMaterial({
            uniforms: {
                uOutlineThickness: { value: params.outlineThickness },
                uOutlineColor: { value: new THREE.Color(params.outlineColor) },
                uOutlineOpacity: { value: 1.0 }
            },
            vertexShader: `
                uniform float uOutlineThickness;
                void main() {
                    vec4 displaced = vec4(position + normal * uOutlineThickness, 1.0);
                    gl_Position = projectionMatrix * modelViewMatrix * displaced;
                }
            `,
            fragmentShader: `
                uniform vec3 uOutlineColor;
                uniform float uOutlineOpacity;
                void main() {
                    gl_FragColor = vec4(uOutlineColor, uOutlineOpacity);
                }
            `,
            side: THREE.BackSide,
        });

        // pixel-art style material shader
        const pixelMaterial = new THREE.ShaderMaterial({
            uniforms: {
                uLight1Direction: { value: new THREE.Vector3(0.5, 0.5, 0.5).normalize() },
                uLight1Color: { value: new THREE.Color(params.light1Color) },
                uLight2Direction: { value: new THREE.Vector3(0.5, 0.5, 0.5).normalize() },
                uLight2Color: { value: new THREE.Color(params.light2Color) },
                uLight3Direction: { value: new THREE.Vector3(0.5, 0.5, 0.5).normalize() },
                uLight3Color: { value: new THREE.Color(params.light3Color) },

                uAmbientLight: { value: new THREE.Color(0xeeeeee) },
                uBrightness: { value: 5.0 },

                uDiffuseMap: { value: null },
                uDitherMode: { value: 0 },
                uDitherTexture: { value: bayerTexture },
                uDitherTextureResolution: { value: new THREE.Vector2(4, 4) },
                uDitherStrength: { value: params.ditherStrength },
                uHalftoneSpacing: { value: params.halftoneSpacing },
                uThresholds: { value: [0.01, 0.075, 0.225, 0.450, 0.800] }, 

                uColorPaletteR: { value: [
                    new THREE.Color(0x000000), new THREE.Color(0x300810),
                    new THREE.Color(0x56100b), new THREE.Color(0x9a230c),
                    new THREE.Color(0xc74614), new THREE.Color(0xf37917)
                ] },
                uColorPaletteG: { value: [
                    new THREE.Color(0x000000), new THREE.Color(0x021912),
                    new THREE.Color(0x021912), new THREE.Color(0x047f2b),
                    new THREE.Color(0x47b224), new THREE.Color(0x9abb26)
                ] },
                uColorPaletteB: { value: [
                    new THREE.Color(0x000000), new THREE.Color(0x090916),
                    new THREE.Color(0x11122e), new THREE.Color(0x132173),
                    new THREE.Color(0x1352c7), new THREE.Color(0x45a4ff)
                ] },
                
                uPixelationMix: { value: 1.0 },
            },
            vertexShader: `
                varying vec3 vNormal;
                varying vec2 vUv;
                void main() {
                    vNormal = normalize(normalMatrix * normal);
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform sampler2D uDiffuseMap;
                uniform float uDitherStrength;
                uniform float uBrightness;

                uniform int uDitherMode;
                uniform sampler2D uDitherTexture;
                uniform vec2 uDitherTextureResolution;
                uniform float uHalftoneSpacing;

                uniform vec3 uLight1Direction; uniform vec3 uLight1Color;
                uniform vec3 uLight2Direction; uniform vec3 uLight2Color;
                uniform vec3 uLight3Direction; uniform vec3 uLight3Color;
                uniform float uThresholds[5];

                uniform vec3 uColorPaletteR[6];
                uniform vec3 uColorPaletteG[6];
                uniform vec3 uColorPaletteB[6];

                varying vec3 vNormal;
                varying vec2 vUv;
                uniform float uPixelationMix;

                vec3 quantizeChannel(float channelValue, vec3 palette[6]) {
                    vec3 quantizedColor = palette[0];
                    if (channelValue > uThresholds[0]) quantizedColor = palette[1];
                    if (channelValue > uThresholds[1]) quantizedColor = palette[2];
                    if (channelValue > uThresholds[2]) quantizedColor = palette[3];
                    if (channelValue > uThresholds[3]) quantizedColor = palette[4];
                    if (channelValue > uThresholds[4]) quantizedColor = palette[5];
                    return quantizedColor;
                }
                void main() {
                    vec4 texColor = texture2D(uDiffuseMap, vUv);
                    float intensity1 = max(0.0, dot(vNormal, uLight1Direction));

                    if (intensity1 > 0.8) { intensity1 = 1.0; } else if (intensity1 > 0.4) { intensity1 = 0.6; } else { intensity1 = 0.2; }
                    float diffuse1 = intensity1;
                    float intensity2 = max(0.0, dot(vNormal, uLight2Direction));
                    if (intensity2 > 0.8) { intensity2 = 1.0; } else if (intensity2 > 0.4) { intensity2 = 0.6; } else { intensity2 = 0.2; }
                    float diffuse2 = intensity2;
                    float intensity3 = max(0.0, dot(vNormal, uLight3Direction));
                    if (intensity3 > 0.8) { intensity3 = 1.0; } else if (intensity3 > 0.4) { intensity3 = 0.6; } else { intensity3 = 0.2; }
                    float diffuse3 = intensity3;

                    vec3 light1Contribution = uLight1Color * diffuse1;
                    vec3 light2Contribution = uLight2Color * diffuse2;
                    vec3 light3Contribution = uLight3Color * diffuse3;
                    vec3 totalIllumination = light1Contribution + light2Contribution + light3Contribution;
                    vec3 litColor = texColor.rgb * totalIllumination * uBrightness;

                    float ditherValue = 0.5;
                    if (uDitherMode == 0) {
                        vec2 ditherUV = gl_FragCoord.xy / uDitherTextureResolution;
                        ditherValue = texture2D(uDitherTexture, ditherUV).r;
                    } else if (uDitherMode == 1) {
                        vec2 gridUV = gl_FragCoord.xy / uHalftoneSpacing;
                        vec2 gridPos = fract(gridUV) - 0.5;
                        float gridDist = length(gridPos) * 1.5;
                        float brightness = (litColor.r + litColor.g + litColor.b) / 3.0;
                        ditherValue = step(gridDist, brightness);
                    }
                    float ditherOffset = (ditherValue - 0.5) * uDitherStrength;

                    float r_channel = litColor.r + ditherOffset;
                    vec3 finalColorR = quantizeChannel(r_channel, uColorPaletteR);
                    float g_channel = litColor.g + ditherOffset;
                    vec3 finalColorG = quantizeChannel(g_channel, uColorPaletteG);
                    float b_channel = litColor.b + ditherOffset;
                    vec3 finalColorB = quantizeChannel(b_channel, uColorPaletteB);

                    vec3 finalPixelColor = finalColorR + finalColorG + finalColorB;
                    vec3 finalColor = mix(litColor, finalPixelColor, uPixelationMix);
                    gl_FragColor = vec4(finalColor, 1.0);
                }
            `
        });

        // --- GUI Setup ---
        const renderFolder = gui.addFolder('Render Settings');
        renderFolder.add(params, 'effectiveResolutionX', 64, 1280, 1).name('Effective Res X').onChange(updateEffectiveRes);
        renderFolder.add(params, 'effectiveResolutionY', 48, 720, 1).name('Effective Res Y').onChange(updateEffectiveRes);
        renderFolder.add(pixelMaterial.uniforms.uDitherStrength, 'value', 0, 1, 0.01).name('Dither Strength');
        renderFolder.add(pixelMaterial.uniforms.uBrightness, 'value', 0, 15, 0.1).name('Brightness');

        renderFolder.add(postFXMaterial.uniforms.uFadeOpacity, 'value', 0, 1, 0.01).name('Fade Opacity');
        renderFolder.addColor(params, 'backgroundColor').name('Background Color').onChange(value => {
            const newColor = new THREE.Color(value);
            scene.background = newColor;
            renderer.setClearColor(newColor);
        });

        const ditherFolder = gui.addFolder('Dithering');
        const halftoneSpacingController = ditherFolder.add(pixelMaterial.uniforms.uHalftoneSpacing, 'value', 2, 32, 0.5).name('Halftone Spacing');
        halftoneSpacingController.disable();
        ditherFolder.add(params, 'ditherPattern', Object.keys(ditherPatterns)).name('Pattern').onChange(value => {
            const selected = ditherPatterns[value];
            pixelMaterial.uniforms.uDitherMode.value = selected.mode;
            if (selected.mode === 0) {
                pixelMaterial.uniforms.uDitherTexture.value = selected.texture;
                pixelMaterial.uniforms.uDitherTextureResolution.value = selected.resolution;
                halftoneSpacingController.disable();
            } else {
                halftoneSpacingController.enable();
            }
        });

        const postFXFolder = gui.addFolder('Post-Processing');
        postFXFolder.add(postFXMaterial.uniforms.uAberrationAmount, 'value', 0, 0.02, 0.001).name('Aberration');
        postFXFolder.add(postFXMaterial.uniforms.uScanlineIntensity, 'value', 0, 0.5, 0.01).name('Scanlines');
        postFXFolder.add(postFXMaterial.uniforms.uCurvatureAmount, 'value', 0, 1.0, 0.01).name('CRT Curvature');

        const outlineFolder = gui.addFolder('Outline Settings');
        outlineFolder.add(params, 'showOutline').name('Show Outline').onChange(toggleOutlineVisibility);
        outlineFolder.add(outlineMaterial.uniforms.uOutlineThickness, 'value', 0, 0.1, 0.001).name('Thickness');
        outlineFolder.addColor(params, 'outlineColor').name('Color').onChange(value => {
            outlineMaterial.uniforms.uOutlineColor.value.set(value);
        });
        const light1Folder = gui.addFolder('Light 1');
        light1Folder.add(pixelMaterial.uniforms.uLight1Direction.value, 'x', -1, 1, 0.01).name('Direction X');
        light1Folder.add(pixelMaterial.uniforms.uLight1Direction.value, 'y', -1, 1, 0.01).name('Direction Y');
        light1Folder.add(pixelMaterial.uniforms.uLight1Direction.value, 'z', -1, 1, 0.01).name('Direction Z');
        light1Folder.addColor(params, 'light1Color').name('Color').onChange(value => {
            pixelMaterial.uniforms.uLight1Color.value.set(value);
        });
        const light2Folder = gui.addFolder('Light 2');
        light2Folder.add(pixelMaterial.uniforms.uLight2Direction.value, 'x', -1, 1, 0.01).name('Direction X');
        light2Folder.add(pixelMaterial.uniforms.uLight2Direction.value, 'y', -1, 1, 0.01).name('Direction Y');
        light2Folder.add(pixelMaterial.uniforms.uLight2Direction.value, 'z', -1, 1, 0.01).name('Direction Z');
        light2Folder.addColor(params, 'light2Color').name('Color').onChange(value => {
            pixelMaterial.uniforms.uLight2Color.value.set(value);
        });
        const light3Folder = gui.addFolder('Light 3');
        light3Folder.add(pixelMaterial.uniforms.uLight3Direction.value, 'x', -1, 1, 0.01).name('Direction X');
        light3Folder.add(pixelMaterial.uniforms.uLight3Direction.value, 'y', -1, 1, 0.01).name('Direction Y');
        light3Folder.add(pixelMaterial.uniforms.uLight3Direction.value, 'z', -1, 1, 0.01).name('Direction Z');
        light3Folder.addColor(params, 'light3Color').name('Color').onChange(value => {
            pixelMaterial.uniforms.uLight3Color.value.set(value);
        });
        const animationFolder = gui.addFolder('Animation');
        const animateModelController = animationFolder.add(params, 'animateModel').name('Animate Model');

        function updateEffectiveRes() {
            postFXMaterial.uniforms.uEffectiveRes.value.set(params.effectiveResolutionX, params.effectiveResolutionY);
        }

        // --- Loader ---
        let model;
        const outlineMeshes = [];
        const originalMaterials = new Map();

        const loader = new GLTFLoader();
        loader.load(
            'assets/fox_quad.glb',
            function (gltf) {
                model = gltf.scene;
                const meshesToProcess = [];

                model.traverse(function (child) {
                    if (child.isMesh) {
                        meshesToProcess.push(child);
                        const standardMaterial = new THREE.MeshBasicMaterial({
                            map: child.material.map,
                        });
                        if(child.material.map) standardMaterial.map.colorSpace = THREE.SRGBColorSpace;
                        originalMaterials.set(child, standardMaterial);
                        child.material = standardMaterial;
                    }
                });

                meshesToProcess.forEach(child => {
                    if (child.material && child.material.map) {
                        child.material.map.colorSpace = THREE.SRGBColorSpace;
                        pixelMaterial.uniforms.uDiffuseMap.value = child.material.map;
                    }

                    const outlineMesh = new THREE.Mesh(child.geometry, outlineMaterial);
                    outlineMesh.position.copy(child.position);
                    outlineMesh.rotation.copy(child.rotation);
                    outlineMesh.scale.copy(child.scale);
                    child.parent.add(outlineMesh); 
                    outlineMeshes.push(outlineMesh);
                });
                
                model.scale.set(5, 5, 5);
                model.position.x = 0;
                model.position.y = 0;
                model.position.z = 0;
                scene.add(model);

                startIntroAnimation();
            },
            undefined,
            function (error) {
                console.error('An error happened', error);
            }
        );

        function easeInOutCubic(x) {
            return x < 0.5 ? 4 * x * x * x : 1 - Math.pow(-2 * x + 2, 3) / 2;
        }

        function toggleOutlineVisibility(isVisible) {
            outlineMeshes.forEach(mesh => {
                mesh.visible = isVisible;
            });
        }

        function toggleAutoAnimate(){
            params.animateModel = true;
            animateModelController.updateDisplay(); 
        }

        const clock = new THREE.Clock();
        const baseSpeed = 0.5;
        const speedAmplitude = 12.0; 

        // --- Animate Loop ---
        function animate() {
            requestAnimationFrame(animate);
            const deltaTime = clock.getDelta();
            controls.update();

            if (model && params.animateModel) {
                const variableSpeed = baseSpeed + Math.sin(clock.getElapsedTime() * 0.8) * speedAmplitude;
                model.rotation.z += variableSpeed * deltaTime;
            }

            // --- INTRO ANIMATION LOGIC (integrated with main loop) ---
            if (introAnimation.isActive) {
                const introTime = performance.now() - introAnimation.startTime;
                const d = introAnimation.duration;
                let progress = 0;

                if (introTime < d.stage1_highRes) {
                    // Stage 1: Clean high-res
                    model.traverse(child => {
                        if (originalMaterials.has(child) && child.material !== originalMaterials.get(child)) {
                            child.material = originalMaterials.get(child);
                        }
                    });
                    toggleOutlineVisibility(false);
                    pixelMaterial.uniforms.uPixelationMix.value = 0.0; // Just in case
                    outlineMaterial.uniforms.uOutlineOpacity.value = 0.0;
                    postFXMaterial.uniforms.uCurvatureAmount.value = 0.0;
                    postFXMaterial.uniforms.uEffectiveRes.value.set(window.innerWidth, window.innerHeight);

                } else if (introTime < introAnimation.totalDuration) {
                    // Stage 2: Gradual transition
                    model.traverse(child => {
                        if (originalMaterials.has(child) && child.material !== pixelMaterial) {
                            child.material = pixelMaterial;
                        }
                    });
                    toggleOutlineVisibility(true);
                    const stageTime = introTime - d.stage1_highRes;
                    progress = easeInOutCubic(stageTime / d.stage2_crtAndPixel);

                    pixelMaterial.uniforms.uPixelationMix.value = progress;
                    outlineMaterial.uniforms.uOutlineOpacity.value = progress;
                    postFXMaterial.uniforms.uCurvatureAmount.value = progress * params.targetCurvature;

                    const effX = THREE.MathUtils.lerp(window.innerWidth, params.effectiveResolutionX, progress);
                    const effY = THREE.MathUtils.lerp(window.innerHeight, params.effectiveResolutionY, progress);
                    postFXMaterial.uniforms.uEffectiveRes.value.set(effX, effY);

                } else {
                    // Finish intro
                    introAnimation.isActive = false;
                    pixelMaterial.uniforms.uPixelationMix.value = 1.0;
                    outlineMaterial.uniforms.uOutlineOpacity.value = 1.0;
                    postFXMaterial.uniforms.uCurvatureAmount.value = params.targetCurvature;
                    postFXMaterial.uniforms.uEffectiveRes.value.set(params.effectiveResolutionX, params.effectiveResolutionY);
                    toggleOutlineVisibility(params.showOutline);
                    // toggleAutoAnimate();
                }
            }
            renderer.setRenderTarget(renderTarget);
            renderer.render(scene, camera);

            postFXMaterial.uniforms.uSceneTexture.value = renderTarget.texture;
            postFXMaterial.uniforms.uPrevFrameTexture.value = readTarget.texture;
            postFXMaterial.uniforms.uFadeOpacity.value = params.fadeOpacity;
            
            renderer.setRenderTarget(writeTarget);
            renderer.render(postFXScene, postFXCamera);

            postFXMaterial.uniforms.uSceneTexture.value = writeTarget.texture;
            postFXMaterial.uniforms.uFadeOpacity.value = 0.0;
            
            renderer.setRenderTarget(null);
            renderer.render(postFXScene, postFXCamera);

            postFXMaterial.uniforms.uFadeOpacity.value = params.fadeOpacity;

            const temp = readTarget;
            readTarget = writeTarget;
            writeTarget = temp;
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            postFXMaterial.uniforms.uResolution.value.set(window.innerWidth, window.innerHeight);
            renderTarget.setSize(window.innerWidth, window.innerHeight);
            readTarget.setSize(window.innerWidth, window.innerHeight);
            writeTarget.setSize(window.innerWidth, window.innerHeight);
            if (!introAnimation.isActive) {
                updateEffectiveRes();
            }
        });

        animate();
    </script>
</body>
</html>